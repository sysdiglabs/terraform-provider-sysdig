package sysdig

import (
	"context"
	"fmt"
	"net/http"
	"regexp"
	"strings"

	v2 "github.com/draios/terraform-provider-sysdig/sysdig/internal/client/v2"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func resourceSysdigSecureVulnerabilityAcceptRisk() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceSysdigSecureVulnerabilityAcceptRiskCreate,
		ReadContext:   resourceSysdigSecureVulnerabilityAcceptRiskRead,
		UpdateContext: resourceSysdigSecureVulnerabilityAcceptRiskUpdate,
		DeleteContext: resourceSysdigSecureVulnerabilityAcceptRiskDelete,
		Schema: map[string]*schema.Schema{
			"cve": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
			},
			"image": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringDoesNotMatch(regexp.MustCompile(`^\\*$`), "image value '*' is not valid"),
				ForceNew:     true,
			},
			"stages": {
				Type:     schema.TypeList,
				Optional: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
				ForceNew: true,
			},
			"reason": {
				Type:         schema.TypeString,
				Required:     true,
				ValidateFunc: validation.StringInSlice([]string{"RiskTransferred", "RiskAvoided", "RiskMitigated", "RiskOwned", "RiskNotRelevant", "Custom"}, false),
			},
			"description": {
				Type:     schema.TypeString,
				Required: true,
			},
			"expiration_date": {
				Type:         schema.TypeString,
				Optional:     true,
				ValidateFunc: validation.StringMatch(regexp.MustCompile(`^\d{4}-\d{2}-\d{2}$`), "must be in YYYY-MM-DD format"),
			},
			"hostname": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
			},
			"hostname_contains": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
			},
			"rule_id": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
			},
			"package_name": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
			},
			"package_version": {
				Type:     schema.TypeString,
				Optional: true,
				ForceNew: true,
			},
		},
	}
}

func resourceSysdigSecureVulnerabilityAcceptRiskCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client, err := getVulnerabilityAcceptRiskClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	reasonType, err := v2.ReasonTypeFromString(d.Get("reason").(string))
	if err != nil {
		return diag.FromErr(err)
	}

	req := &v2.AcceptVulnerabilityRiskRequest{
		Reason:      reasonType,
		Description: d.Get("description").(string),
		Context:     []v2.AcceptVulnerabilityRiskContext{},
	}

	if err := validateCombination(d); err != nil {
		return diag.Errorf("%s", err)
	}

	if cve, ok := d.GetOk("cve"); ok {
		req.EntityType = v2.EntityTypeVulnerability
		req.EntityValue = cve.(string)
		setContextFromFields(d, req)
	} else if ruleID, ok := d.GetOk("rule_id"); ok {
		req.EntityType = v2.EntityTypePolicyRule
		req.EntityValue = ruleID.(string)
		setContextFromFields(d, req)
	} else if image, ok := d.GetOk("image"); ok {
		entityType, entityValue := getImageTypeAndValue(image.(string))
		req.EntityType = v2.EntityType(entityType)
		req.EntityValue = entityValue
	} else if hostname, ok := d.GetOk("hostname"); ok {
		req.EntityType = v2.EntityTypeHostName
		req.EntityValue = hostname.(string)
	} else if hostnameContains, ok := d.GetOk("hostname_contains"); ok {
		req.EntityType = v2.EntityTypeHostNameContains
		req.EntityValue = hostnameContains.(string)
	} else {
		return diag.Errorf("invalid combination of fields provided")
	}

	if expirationDate, ok := d.GetOk("expiration_date"); ok {
		req.ExpirationDate = expirationDate.(string)
	}

	if stages, ok := d.GetOk("stages"); ok {
		for _, stage := range stages.([]interface{}) {
			req.Stages = append(req.Stages, v2.StageType(stage.(string)))
		}
	}

	created, _, err := client.SaveAcceptVulnerabilityRisk(ctx, req)
	if err != nil {
		return diag.FromErr(err)
	}
	d.SetId(created.ID)

	return resourceSysdigSecureVulnerabilityAcceptRiskRead(ctx, d, meta)
}

func validateCombination(d *schema.ResourceData) error {
	_, hasCVE := d.GetOk("cve")
	_, hasRuleID := d.GetOk("rule_id")
	_, hasImage := d.GetOk("image")
	_, hasHostname := d.GetOk("hostname")
	_, hasHostnameContains := d.GetOk("hostname_contains")
	_, hasPackageName := d.GetOk("package_name")
	_, hasPackageVersion := d.GetOk("package_version")

	switch {
	// Valid case: only hostname specified
	case !hasCVE && !hasRuleID && !hasImage && hasHostname && !hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only hostname_contains specified
	case !hasCVE && !hasRuleID && !hasImage && !hasHostname && hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only image specified
	case !hasCVE && !hasRuleID && hasImage && !hasHostname && !hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only rule_id is specified
	case !hasCVE && hasRuleID && !hasImage && !hasHostname && !hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only rule_id with image is specified
	case !hasCVE && hasRuleID && hasImage && !hasHostname && !hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only rule_id with hostname is specified
	case !hasCVE && hasRuleID && !hasImage && hasHostname && !hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only rule_id with hostname_contains is specified
	case !hasCVE && hasRuleID && !hasImage && !hasHostname && hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only CVE is specified
	case hasCVE && !hasRuleID && !hasImage && !hasHostname && !hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only CVE with image is specified
	case hasCVE && !hasRuleID && hasImage && !hasHostname && !hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only CVE with hostname is specified
	case hasCVE && !hasRuleID && !hasImage && hasHostname && !hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only CVE with hostname_contains is specified
	case hasCVE && !hasRuleID && !hasImage && !hasHostname && hasHostnameContains && !hasPackageName && !hasPackageVersion:
		return nil
	// Valid case: only CVE with package is specified
	case hasCVE && !hasRuleID && !hasImage && !hasHostname && !hasHostnameContains && hasPackageName:
		return nil
	}

	return fmt.Errorf("no valid combination of fields provided, check the provided examples in the docs for valid combinations")
}

func getImageTypeAndValue(image string) (string, string) {
	trimmedImage := strings.Trim(image, "*")
	if len(image) == 0 {
		return string(v2.EntityTypeImageName), trimmedImage
	}

	switch {
	case image[0] == '*' && image[len(image)-1] == '*':
		return string(v2.EntityTypeImageNameContains), trimmedImage
	case image[0] == '*':
		return string(v2.EntityTypeImageSuffix), trimmedImage
	case image[len(image)-1] == '*':
		return string(v2.EntityTypeImagePrefix), trimmedImage
	default:
		return string(v2.EntityTypeImageName), trimmedImage
	}
}

func setContextFromFields(d *schema.ResourceData, req *v2.AcceptVulnerabilityRiskRequest) {
	if image, ok := d.GetOk("image"); ok {
		contextType, contextValue := getImageTypeAndValue(image.(string))
		req.Context = append(req.Context, v2.AcceptVulnerabilityRiskContext{
			ContextType:  v2.ContextType(contextType),
			ContextValue: contextValue,
		})
	}
	if hostname, ok := d.GetOk("hostname"); ok {
		req.Context = append(req.Context, v2.AcceptVulnerabilityRiskContext{
			ContextType:  v2.ContextTypeHostName,
			ContextValue: hostname.(string),
		})
	}
	if hostnameContains, ok := d.GetOk("hostname_contains"); ok {
		req.Context = append(req.Context, v2.AcceptVulnerabilityRiskContext{
			ContextType:  v2.ContextTypeHostNameContains,
			ContextValue: hostnameContains.(string),
		})
	}
	if pkg, ok := d.GetOk("package_name"); ok {
		req.Context = append(req.Context, v2.AcceptVulnerabilityRiskContext{
			ContextType:  v2.ContextTypePackageName,
			ContextValue: pkg.(string),
		})
	}
	if pkgVersion, ok := d.GetOk("package_version"); ok {
		req.Context = append(req.Context, v2.AcceptVulnerabilityRiskContext{
			ContextType:  v2.ContextTypePackageVersion,
			ContextValue: pkgVersion.(string),
		})
	}
}

func resourceSysdigSecureVulnerabilityAcceptRiskRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client, err := getVulnerabilityAcceptRiskClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	id := d.Id()
	result, statusCode, err := client.GetAcceptanceVulnerabilityRisk(ctx, id)
	if err != nil {
		if statusCode == http.StatusNotFound {
			d.SetId("")
			return nil
		} else {
			return diag.FromErr(err)
		}
	}
	_ = d.Set("reason", result.Reason)
	_ = d.Set("description", result.Description)
	if result.ExpirationDate != "" {
		_ = d.Set("expiration_date", result.ExpirationDate)
	}
	_ = d.Set("stages", result.Stages)
	switch result.EntityType {
	case v2.EntityTypeImageName:
		_ = d.Set("image", result.EntityValue)
	case v2.EntityTypeImagePrefix:
		_ = d.Set("image", result.EntityValue+"*")
	case v2.EntityTypeImageSuffix:
		_ = d.Set("image", "*"+result.EntityValue)
	case v2.EntityTypeImageNameContains:
		_ = d.Set("image", "*"+result.EntityValue+"*")
	case v2.EntityTypeVulnerability:
		_ = d.Set("cve", result.EntityValue)
		fillResourceDataFromContextSlice(d, result.Context)
	case v2.EntityTypeHostName:
		_ = d.Set("hostname", result.EntityValue)
	case v2.EntityTypeHostNameContains:
		_ = d.Set("hostname_contains", result.EntityValue)
	case v2.EntityTypePolicyRule:
		_ = d.Set("rule_id", result.EntityValue)
		fillResourceDataFromContextSlice(d, result.Context)
	default:
		panic(fmt.Sprintf("unexpected v2.EntityType: %#v", result.EntityType))
	}
	return nil
}

func fillResourceDataFromContextSlice(d *schema.ResourceData, contextSlice []v2.AcceptVulnerabilityRiskContext) {
	for _, context := range contextSlice {
		fillResourceDataFromContext(d, context)
	}
}

func fillResourceDataFromContext(d *schema.ResourceData, context v2.AcceptVulnerabilityRiskContext) {
	switch context.ContextType {
	case v2.ContextTypeHostName:
		_ = d.Set("hostname", context.ContextValue)
	case v2.ContextTypeHostNameContains:
		_ = d.Set("hostname_contains", context.ContextValue)
	case v2.ContextTypeImageName:
		_ = d.Set("image", context.ContextValue)
	case v2.ContextTypeImageNameContains:
		_ = d.Set("image", "*"+context.ContextValue+"*")
	case v2.ContextTypeImagePrefix:
		_ = d.Set("image", context.ContextValue+"*")
	case v2.ContextTypeImageSuffix:
		_ = d.Set("image", "*"+context.ContextValue)
	case v2.ContextTypePackageName:
		_ = d.Set("package_name", context.ContextValue)
	case v2.ContextTypePackageVersion:
		_ = d.Set("package_version", context.ContextValue)
	default:
		panic(fmt.Sprintf("unexpected v2.ContextType: %#v", context.ContextType))
	}
}

func resourceSysdigSecureVulnerabilityAcceptRiskUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client, err := getVulnerabilityAcceptRiskClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	id := d.Id()

	reasonType, err := v2.ReasonTypeFromString(d.Get("reason").(string))
	if err != nil {
		return diag.FromErr(err)
	}

	req := &v2.UpdateAcceptVulnerabilityRiskRequest{
		ID:          id,
		Reason:      reasonType,
		Description: d.Get("description").(string),
	}

	if expirationDate, ok := d.GetOk("expiration_date"); ok {
		req.ExpirationDate = expirationDate.(string)
	}

	_, _, err = client.UpdateAcceptanceVulnerabilityRisk(ctx, req)
	if err != nil {
		return diag.FromErr(err)
	}
	return resourceSysdigSecureVulnerabilityAcceptRiskRead(ctx, d, meta)
}

func resourceSysdigSecureVulnerabilityAcceptRiskDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client, err := getVulnerabilityAcceptRiskClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	id := d.Id()
	if err := client.DeleteAcceptanceVulnerabilityRisk(ctx, id); err != nil {
		return diag.FromErr(err)
	}
	d.SetId("")
	return nil
}

func getVulnerabilityAcceptRiskClient(c SysdigClients) (v2.PostureVulnerabilityAcceptRiskInterface, error) {
	var client v2.PostureVulnerabilityAcceptRiskInterface
	var err error
	switch c.GetClientType() {
	case IBMSecure:
		client, err = c.ibmSecureClient()
		if err != nil {
			return nil, err
		}
	default:
		client, err = c.sysdigSecureClientV2()
		if err != nil {
			return nil, err
		}
	}
	return client, nil
}
