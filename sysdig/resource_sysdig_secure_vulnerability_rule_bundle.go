package sysdig

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	v2 "github.com/draios/terraform-provider-sysdig/sysdig/internal/client/v2"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func vulnerabilityRuleSchemaImageConfigLabel() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeSet,
		Optional:    true,
		MaxItems:    1,
		Description: "Defines label-based matching rules for image configuration.",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Internal identifier for the label rule block.",
				},
				"label_must_exist": {
					Type:        schema.TypeString,
					Optional:    true,
					Description: "A label key that must exist in the image configuration for the rule to match.",
				},
				"label_must_not_exist": {
					Type:        schema.TypeString,
					Optional:    true,
					Description: "A label key that must not exist in the image configuration for the rule to match.",
				},
				"label_must_exist_and_contain_value": {
					Type:        schema.TypeList,
					Optional:    true,
					Description: "List of label-value pairs that must exist in the image configuration for the rule to match.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"required_label": {
								Type:        schema.TypeString,
								Required:    true,
								Description: "Label key that must exist in the image configuration.",
							},
							"required_value": {
								Type:        schema.TypeString,
								Required:    true,
								Description: "Expected value for the given label key.",
							},
						},
					},
				},
			},
		},
	}
}

func resourceSysdigSecureVulnerabilityRuleBundle() *schema.Resource {
	timeout := 5 * time.Minute

	return &schema.Resource{
		CreateContext: resourceSysdigVulnerabilityRuleBundleCreate,
		ReadContext:   resourceSysdigVulnerabilityRuleBundleRead,
		UpdateContext: resourceSysdigVulnerabilityRuleBundleUpdate,
		DeleteContext: resourceSysdigVulnerabilityRuleBundleDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(timeout),
			Delete: schema.DefaultTimeout(timeout),
			Update: schema.DefaultTimeout(timeout),
			Read:   schema.DefaultTimeout(timeout),
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Rule Bundle name",
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Rule Bundle description",
			},
			"identifier": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "External identifier",
			},

			"rule": {
				Type:        schema.TypeList,
				Required:    true,
				MinItems:    1,
				Description: "Rules for this bundle",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"image_label":            vulnerabilityRuleSchemaImageConfigLabel(),
						"severities_and_threats": vulnerabilityRuleSchemaSeveritiesAndThreats(),
					},
				},
			},
		},
	}
}

func vulnerabilityRuleSchemaSeveritiesAndThreats() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeSet,
		Optional:    true,
		MaxItems:    1,
		Description: "Defines rules based on vulnerability severity and threat intelligence.",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Internal identifier for the severities and threats rule block.",
				},
				"severity_at_least": {
					Type:        schema.TypeString,
					Optional:    true,
					Description: "Vulnerability severity must be at least this level (critical, high, medium, low, negligible).",
				},
				"severity_equals": {
					Type:        schema.TypeString,
					Optional:    true,
					Description: "Vulnerability severity must be exactly this level.",
				},
				"cvss_at_least": {
					Type:        schema.TypeFloat,
					Optional:    true,
					Description: "Vulnerability CVSS score must be at least this value.",
				},
				"disclosure_older_than_days": {
					Type:        schema.TypeInt,
					Optional:    true,
					Description: "Vulnerability was disclosed more than this number of days ago.",
				},
				"disclosure_date": {
					Type:        schema.TypeList,
					Optional:    true,
					MaxItems:    1,
					Description: "Vulnerability was disclosed within this date range.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"from": {
								Type:        schema.TypeString,
								Required:    true,
								Description: "Start of the date range (YYYY-MM-DD).",
							},
							"to": {
								Type:        schema.TypeString,
								Required:    true,
								Description: "End of the date range (YYYY-MM-DD).",
							},
						},
					},
				},
				"package_type": {
					Type:        schema.TypeString,
					Optional:    true,
					Description: "Type of the package (e.g., 'os', 'npm', 'maven').",
				},
				"in_use": {
					Type:        schema.TypeBool,
					Optional:    true,
					Description: "Package is currently in use at runtime.",
				},
				"fix_available": {
					Type:        schema.TypeBool,
					Optional:    true,
					Description: "A fix is available for the vulnerability.",
				},
				"fix_available_since_days": {
					Type:        schema.TypeInt,
					Optional:    true,
					Description: "A fix has been available for at least this number of days.",
				},
				"public_exploit_available": {
					Type:        schema.TypeBool,
					Optional:    true,
					Description: "A public exploit is available for the vulnerability.",
				},
				"public_exploit_available_since_days": {
					Type:        schema.TypeInt,
					Optional:    true,
					Description: "A public exploit has been available for at least this number of days.",
				},
				"exploit_no_admin_privileges": {
					Type:        schema.TypeBool,
					Optional:    true,
					Description: "Exploit does not require admin privileges.",
				},
				"exploit_no_user_interaction": {
					Type:        schema.TypeBool,
					Optional:    true,
					Description: "Exploit does not require user interaction.",
				},
				"exploit_network_attack_vector": {
					Type:        schema.TypeBool,
					Optional:    true,
					Description: "Exploit has a network attack vector.",
				},
				"cisa_kev_in_ransomware_campaign": {
					Type:        schema.TypeBool,
					Optional:    true,
					Description: "Vulnerability is in a CISA KEV ransomware campaign.",
				},
				"cisa_kev_available_since_days": {
					Type:        schema.TypeInt,
					Optional:    true,
					Description: "Vulnerability has been in CISA KEV for at least this number of days.",
				},
				"cisa_kev_due_date_in_days": {
					Type:        schema.TypeInt,
					Optional:    true,
					Description: "CISA KEV due date is within this number of days.",
				},
				"epss_score_at_least_percentage": {
					Type:        schema.TypeInt,
					Optional:    true,
					Description: "EPSS score is at least this percentage.",
				},
				"epss_percentile_at_least_percentage": {
					Type:        schema.TypeInt,
					Optional:    true,
					Description: "EPSS percentile is at least this percentage.",
				},
			},
		},
	}
}

func getSecureVulnerabilityRuleBundleClient(c SysdigClients) (v2.VulnerabilityRuleBundleClient, error) {
	return c.sysdigSecureClientV2()
}

func resourceSysdigVulnerabilityRuleBundleCreate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityRuleBundleClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	scanningRuleBundle, err := vulnerabilityRuleBundleFromResourceData(d)
	if err != nil {
		return diag.FromErr(err)
	}

	scanningRuleBundle, err = client.CreateVulnerabilityRuleBundle(ctx, scanningRuleBundle)
	if err != nil {
		return diag.FromErr(err)
	}

	err = vulnerabilityRuleBundleToResourceData(&scanningRuleBundle, d)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceSysdigVulnerabilityRuleBundleUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityRuleBundleClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	scanningRuleBundle, err := vulnerabilityRuleBundleFromResourceData(d)
	if err != nil {
		return diag.FromErr(err)
	}

	_, err = client.UpdateVulnerabilityRuleBundle(ctx, scanningRuleBundle)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceSysdigVulnerabilityRuleBundleRead(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityRuleBundleClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	scanningRuleBundle, err := client.GetVulnerabilityRuleBundleByID(ctx, d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	err = vulnerabilityRuleBundleToResourceData(&scanningRuleBundle, d)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceSysdigVulnerabilityRuleBundleDelete(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityRuleBundleClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	err = client.DeleteVulnerabilityRuleBundleByID(ctx, d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func vulnerabilityRuleBundleToResourceData(scanningRuleBundle *v2.VulnerabilityRuleBundle, d *schema.ResourceData) error {
	if scanningRuleBundle.ID == nil {
		d.SetId("") // id is nil, let's destroy the resource
		return nil
	}

	d.SetId(strconv.Itoa(int(*scanningRuleBundle.ID)))
	_ = d.Set("name", scanningRuleBundle.Name)
	_ = d.Set("description", scanningRuleBundle.Description)

	if scanningRuleBundle.Identifier != nil {
		_ = d.Set("identifier", *scanningRuleBundle.Identifier)
	}

	ruleData, err := vulnerabilityRulesToData(scanningRuleBundle.Rules)
	if err != nil {
		return err
	}
	_ = d.Set("rule", ruleData)

	return nil
}

func vulnerabilityRulesToData(scanningRuleBundle []v2.VulnerabilityRule) ([]map[string]any, error) {
	var rules []map[string]any

	for _, ruleBundle := range scanningRuleBundle {
		data, err := vulnerabilityRuleToData(ruleBundle)
		if err != nil {
			return nil, err
		}
		rules = append(rules, data)
	}

	return rules, nil
}

func vulnerabilityRuleToData(ruleBundle v2.VulnerabilityRule) (map[string]any, error) {
	switch ruleBundle.Type {
	case v2.VulnerabilityRuleTypeImageConfigLabel:
		return vulnerabilityRuleImageConfigLabelToData(ruleBundle)
	case v2.VulnerabilityRuleTypeVulnSeverityAndThreats:
		return vulnerabilityRuleSeveritiesAndThreatsToData(ruleBundle)
	default:
		return nil, fmt.Errorf("unsupported rule bundle type: %s", ruleBundle.Type)
	}
}

func vulnerabilityRuleSeveritiesAndThreatsToData(ruleBundle v2.VulnerabilityRule) (map[string]any, error) {
	ruleData := map[string]any{
		"id": ruleBundle.ID,
	}

	for _, predicate := range ruleBundle.Predicates {
		switch predicate.Type {
		case "vulnSeverity":
			ruleData["severity_at_least"] = predicate.Extra.Level
		case "vulnSeverityEquals":
			ruleData["severity_equals"] = predicate.Extra.Level
		case "vulnCVSS":
			// The value comes as float64 from the API, which is the type in the schema
			if v, ok := predicate.Extra.Value.(float64); ok {
				ruleData["cvss_at_least"] = v
			}
		case "vulnAge":
			ruleData["disclosure_older_than_days"] = predicate.Extra.Age
		case "vulnDisclosureRange":
			ruleData["disclosure_date"] = []map[string]any{
				{
					"from": predicate.Extra.StartDate,
					"to":   predicate.Extra.EndDate,
				},
			}
		case "vulnPkgType":
			ruleData["package_type"] = predicate.Extra.PkgType
		case "vulnIsInUse":
			ruleData["in_use"] = true
		case "vulnIsFixable":
			ruleData["fix_available"] = true
		case "vulnIsFixableWithAge":
			ruleData["fix_available_since_days"] = predicate.Extra.Age
		case "vulnIsExploitable":
			ruleData["public_exploit_available"] = true
		case "vulnExploitableWithAge":
			ruleData["public_exploit_available_since_days"] = predicate.Extra.Age
		case "vulnExploitableNoAdmin":
			ruleData["exploit_no_admin_privileges"] = true
		case "vulnExploitableNoUser":
			ruleData["exploit_no_user_interaction"] = true
		case "vulnExploitableViaNetwork":
			ruleData["exploit_network_attack_vector"] = true
		case "cisaKevKnownRansomwareCampaignUse":
			ruleData["cisa_kev_in_ransomware_campaign"] = true
		case "cisaKevAvailableSince":
			ruleData["cisa_kev_available_since_days"] = predicate.Extra.Days
		case "cisaKevDueDateIn":
			ruleData["cisa_kev_due_date_in_days"] = predicate.Extra.Days
		case "vulnEpssScoreGte":
			ruleData["epss_score_at_least_percentage"] = predicate.Extra.Score
		case "vulnEpssPercentileGte":
			ruleData["epss_percentile_at_least_percentage"] = predicate.Extra.Percentile
		}
	}

	return map[string]any{
		"severities_and_threats": []any{ruleData},
	}, nil
}

func vulnerabilityRuleSeveritiesAndThreatsFromMap(ruleBody map[string]any) (v2.VulnerabilityRule, error) {
	if err := validateSeveritiesAndThreatsRule(ruleBody); err != nil {
		return v2.VulnerabilityRule{}, err
	}

	rule := v2.VulnerabilityRule{
		ID:         toPtr(ruleBody["id"].(string)),
		Type:       v2.VulnerabilityRuleTypeVulnSeverityAndThreats,
		Predicates: []v2.VulnerabilityRulePredicate{},
	}

	addPredicate := func(predicateType string, extra *v2.VulnerabilityRulePredicateExtra) {
		rule.Predicates = append(rule.Predicates, v2.VulnerabilityRulePredicate{
			Type:  predicateType,
			Extra: extra,
		})
	}

	if val, ok := ruleBody["severity_at_least"]; ok && val.(string) != "" {
		level := v2.Level(val.(string))
		addPredicate("vulnSeverity", &v2.VulnerabilityRulePredicateExtra{Level: &level})
	}

	if val, ok := ruleBody["severity_equals"]; ok && val.(string) != "" {
		level := v2.Level(val.(string))
		addPredicate("vulnSeverityEquals", &v2.VulnerabilityRulePredicateExtra{Level: &level})
	}

	if val, ok := ruleBody["cvss_at_least"]; ok && val.(float64) > 0 {
		score := val.(float64)
		addPredicate("vulnCVSS", &v2.VulnerabilityRulePredicateExtra{Value: &score})
	}

	if val, ok := ruleBody["disclosure_older_than_days"]; ok && val.(int) > 0 {
		days := val.(int)
		addPredicate("vulnAge", &v2.VulnerabilityRulePredicateExtra{Age: &days})
	}

	if val, ok := ruleBody["disclosure_date"]; ok && len(val.([]any)) > 0 {
		dates := val.([]any)[0].(map[string]any)
		startDate := dates["from"].(string)
		endDate := dates["to"].(string)
		addPredicate("vulnDisclosureRange", &v2.VulnerabilityRulePredicateExtra{StartDate: &startDate, EndDate: &endDate})
	}

	if val, ok := ruleBody["package_type"]; ok && val.(string) != "" {
		pkgType := val.(string)
		addPredicate("vulnPkgType", &v2.VulnerabilityRulePredicateExtra{PkgType: &pkgType})
	}

	if val, ok := ruleBody["in_use"]; ok && val.(bool) {
		addPredicate("vulnIsInUse", nil)
	}

	if val, ok := ruleBody["fix_available"]; ok && val.(bool) {
		addPredicate("vulnIsFixable", nil)
	}

	if val, ok := ruleBody["fix_available_since_days"]; ok && val.(int) > 0 {
		days := val.(int)
		addPredicate("vulnIsFixableWithAge", &v2.VulnerabilityRulePredicateExtra{Age: &days})
	}

	if val, ok := ruleBody["public_exploit_available"]; ok && val.(bool) {
		addPredicate("vulnIsExploitable", nil)
	}

	if val, ok := ruleBody["public_exploit_available_since_days"]; ok && val.(int) > 0 {
		days := val.(int)
		addPredicate("vulnExploitableWithAge", &v2.VulnerabilityRulePredicateExtra{Age: &days})
	}

	if val, ok := ruleBody["exploit_no_admin_privileges"]; ok && val.(bool) {
		addPredicate("vulnExploitableNoAdmin", nil)
	}

	if val, ok := ruleBody["exploit_no_user_interaction"]; ok && val.(bool) {
		addPredicate("vulnExploitableNoUser", nil)
	}

	if val, ok := ruleBody["exploit_network_attack_vector"]; ok && val.(bool) {
		addPredicate("vulnExploitableViaNetwork", nil)
	}

	if val, ok := ruleBody["cisa_kev_in_ransomware_campaign"]; ok && val.(bool) {
		addPredicate("cisaKevKnownRansomwareCampaignUse", nil)
	}

	if val, ok := ruleBody["cisa_kev_available_since_days"]; ok && val.(int) > 0 {
		days := val.(int)
		addPredicate("cisaKevAvailableSince", &v2.VulnerabilityRulePredicateExtra{Days: &days})
	}

	if val, ok := ruleBody["cisa_kev_due_date_in_days"]; ok && val.(int) > 0 {
		days := val.(int)
		addPredicate("cisaKevDueDateIn", &v2.VulnerabilityRulePredicateExtra{Days: &days})
	}

	if val, ok := ruleBody["epss_score_at_least_percentage"]; ok && val.(int) > 0 {
		score := val.(int)
		addPredicate("vulnEpssScoreGte", &v2.VulnerabilityRulePredicateExtra{Score: &score})
	}

	if val, ok := ruleBody["epss_percentile_at_least_percentage"]; ok && val.(int) > 0 {
		percentile := val.(int)
		addPredicate("vulnEpssPercentileGte", &v2.VulnerabilityRulePredicateExtra{Percentile: &percentile})
	}

	if len(rule.Predicates) == 0 {
		return v2.VulnerabilityRule{}, errors.New("no predicate has been specified for severities_and_threats rule")
	}

	return rule, nil
}

func vulnerabilityRuleImageConfigLabelToData(ruleBundle v2.VulnerabilityRule) (map[string]any, error) {
	switch ruleBundle.Predicates[0].Type {
	case "imageConfigLabelNotExists":
		return map[string]any{
			"image_label": []map[string]any{{
				"id":               ruleBundle.ID,
				"label_must_exist": ruleBundle.Predicates[0].Extra.Key,
			}},
		}, nil
	case "imageConfigLabelExists":
		return map[string]any{
			"image_label": []map[string]any{{
				"id":                   ruleBundle.ID,
				"label_must_not_exist": ruleBundle.Predicates[0].Extra.Key,
			}},
		}, nil
	case "imageConfigLabelNotContains":
		return map[string]any{
			"image_label": []map[string]any{{
				"id": ruleBundle.ID,
				"label_must_exist_and_contain_value": []map[string]any{{
					"required_label": ruleBundle.Predicates[0].Extra.Key,
					"required_value": ruleBundle.Predicates[0].Extra.Value,
				}},
			}},
		}, nil
	}

	return nil, fmt.Errorf("unsupported image config label rule for predicate: %s", ruleBundle.Predicates[0].Type)
}

func toPtr[T any](any T) *T {
	return &any
}

func vulnerabilityRuleBundleFromResourceData(d *schema.ResourceData) (v2.VulnerabilityRuleBundle, error) {
	stringPtr := func(d *schema.ResourceData, key string) *string {
		if value, ok := d.GetOk(key); ok && value.(string) != "" {
			valueAsString := value.(string)
			return &valueAsString
		}
		return nil
	}

	int32PtrFromID := func(d *schema.ResourceData) *int {
		id := d.Id()
		if id == "" {
			return nil
		}

		idAsInt, err := strconv.Atoi(id)
		if err != nil {
			return nil
		}

		return &idAsInt
	}

	rules, err := vulnerabilityRulesFromList(d.Get("rule").([]any))
	if err != nil {
		return v2.VulnerabilityRuleBundle{}, err
	}

	return v2.VulnerabilityRuleBundle{
		ID:          int32PtrFromID(d),
		Identifier:  stringPtr(d, "identifier"),
		Name:        d.Get("name").(string),
		Description: toPtr(d.Get("description").(string)),
		Rules:       rules,
	}, nil
}

func vulnerabilityRulesFromList(list []any) ([]v2.VulnerabilityRule, error) {
	var out []v2.VulnerabilityRule

	for _, ruleRaw := range list {
		if ruleRaw == nil {
			return nil, errors.New("empty rule detected, you need to specify one")
		}
		rule, err := vulnerabilityRuleFromMap(ruleRaw.(map[string]any))
		if err != nil {
			return nil, err
		}
		out = append(out, rule)
	}

	return out, nil
}

func validateRuleMap(ruleMap map[string]any) error {
	var activeRuleNames []string
	for key, val := range ruleMap {
		if val.(*schema.Set).Len() > 0 {
			activeRuleNames = append(activeRuleNames, key)
		}
	}

	if len(activeRuleNames) == 0 {
		return errors.New("you must specify one rule")
	}

	if len(activeRuleNames) > 1 {
		return fmt.Errorf("you can only specify one rule per rule block, specify more rule blocks if you need more rules, you specified: %s", activeRuleNames)
	}

	return nil
}

func vulnerabilityRuleFromMap(ruleMap map[string]any) (v2.VulnerabilityRule, error) {
	err := validateRuleMap(ruleMap)
	if err != nil {
		return v2.VulnerabilityRule{}, err
	}

	for ruleType, ruleBody := range ruleMap {
		if ruleBody.(*schema.Set).Len() == 0 {
			continue
		}
		switch v2.VulnerabilityRuleType(ruleType) {
		case "image_label":
			return vulnerabilityRuleImageConfigLabelFromMap(ruleBody.(*schema.Set).List()[0].(map[string]any))
		case "severities_and_threats":
			return vulnerabilityRuleSeveritiesAndThreatsFromMap(ruleBody.(*schema.Set).List()[0].(map[string]any))
		}

		return v2.VulnerabilityRule{}, fmt.Errorf("unsupported rule type: %s", ruleType)
	}
	panic("unreachable")
}

func validateSeveritiesAndThreatsRule(ruleBody map[string]any) error {
	// Programmatic validation for mutually exclusive fields.
	severityConflictCount := 0
	if val, ok := ruleBody["severity_at_least"]; ok && val.(string) != "" {
		severityConflictCount++
	}
	if val, ok := ruleBody["severity_equals"]; ok && val.(string) != "" {
		severityConflictCount++
	}
	if val, ok := ruleBody["cvss_at_least"]; ok && val.(float64) > 0 {
		severityConflictCount++
	}
	if severityConflictCount > 1 {
		return errors.New("only one of 'severity_at_least', 'severity_equals', or 'cvss_at_least' can be set")
	}

	disclosureConflictCount := 0
	if val, ok := ruleBody["disclosure_older_than_days"]; ok && val.(int) > 0 {
		disclosureConflictCount++
	}
	if val, ok := ruleBody["disclosure_date"]; ok && len(val.([]any)) > 0 {
		disclosureConflictCount++
	}
	if disclosureConflictCount > 1 {
		return errors.New("`disclosure_older_than_days` and `disclosure_date` are mutually exclusive")
	}

	exploitConflictCount := 0
	if val, ok := ruleBody["public_exploit_available"]; ok && val.(bool) {
		exploitConflictCount++
	}
	if val, ok := ruleBody["public_exploit_available_since_days"]; ok && val.(int) > 0 {
		exploitConflictCount++
	}
	if exploitConflictCount > 1 {
		return errors.New("`public_exploit_available` and `public_exploit_available_since_days` are mutually exclusive")
	}

	fixConflictCount := 0
	if val, ok := ruleBody["fix_available"]; ok && val.(bool) {
		fixConflictCount++
	}
	if val, ok := ruleBody["fix_available_since_days"]; ok && val.(int) > 0 {
		fixConflictCount++
	}
	if fixConflictCount > 1 {
		return errors.New("`fix_available` and `fix_available_since_days` are mutually exclusive")
	}

	return nil
}



func vulnerabilityRuleImageConfigLabelFromMap(ruleBody map[string]any) (v2.VulnerabilityRule, error) {
	rule := v2.VulnerabilityRule{
		ID:         toPtr(ruleBody["id"].(string)),
		Type:       v2.VulnerabilityRuleTypeImageConfigLabel,
		Predicates: []v2.VulnerabilityRulePredicate{},
	}

	if label, ok := ruleBody["label_must_exist"]; ok && label.(string) != "" {
		rule.Predicates = append(rule.Predicates, v2.VulnerabilityRulePredicate{
			Type: "imageConfigLabelNotExists",
			Extra: &v2.VulnerabilityRulePredicateExtra{
				Key: toPtr(label.(string)),
			},
		})
	}

	if label, ok := ruleBody["label_must_not_exist"]; ok && label.(string) != "" {
		rule.Predicates = append(rule.Predicates, v2.VulnerabilityRulePredicate{
			Type: "imageConfigLabelExists",
			Extra: &v2.VulnerabilityRulePredicateExtra{
				Key: toPtr(label.(string)),
			},
		})
	}

	if label, ok := ruleBody["label_must_exist_and_contain_value"]; ok && len(label.([]any)) > 0 {
		contents := label.([]any)[0].(map[string]any)
		rule.Predicates = append(rule.Predicates, v2.VulnerabilityRulePredicate{
			Type: "imageConfigLabelNotContains",
			Extra: &v2.VulnerabilityRulePredicateExtra{
				Key:   toPtr(contents["required_label"].(string)),
				Value: toPtr(contents["required_value"].(string)),
			},
		})
	}

	if len(rule.Predicates) == 0 {
		return v2.VulnerabilityRule{}, errors.New("no predicate has been specified for image label rule")
	}

	return rule, nil
}
