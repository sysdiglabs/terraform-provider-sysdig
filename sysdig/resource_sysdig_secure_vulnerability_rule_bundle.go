package sysdig

import (
	"context"
	"errors"
	"fmt"
	"strconv"
	"time"

	v2 "github.com/draios/terraform-provider-sysdig/sysdig/internal/client/v2"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

func vulnerabilityRuleSchemaImageConfigLabel() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeSet,
		Optional:    true,
		MaxItems:    1,
		Description: "Defines label-based matching rules for image configuration.",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{
				"id": {
					Type:        schema.TypeString,
					Computed:    true,
					Description: "Internal identifier for the label rule block.",
				},
				"label_must_exist": {
					Type:        schema.TypeString,
					Optional:    true,
					Description: "A label key that must exist in the image configuration for the rule to match.",
				},
				"label_must_not_exist": {
					Type:        schema.TypeString,
					Optional:    true,
					Description: "A label key that must not exist in the image configuration for the rule to match.",
				},
				"label_must_exist_and_contain_value": {
					Type:        schema.TypeList,
					Optional:    true,
					Description: "List of label-value pairs that must exist in the image configuration for the rule to match.",
					Elem: &schema.Resource{
						Schema: map[string]*schema.Schema{
							"required_label": {
								Type:        schema.TypeString,
								Required:    true,
								Description: "Label key that must exist in the image configuration.",
							},
							"required_value": {
								Type:        schema.TypeString,
								Required:    true,
								Description: "Expected value for the given label key.",
							},
						},
					},
				},
			},
		},
	}
}

func resourceSysdigSecureVulnerabilityRuleBundle() *schema.Resource {
	timeout := 5 * time.Minute

	return &schema.Resource{
		CreateContext: resourceSysdigVulnerabilityRuleBundleCreate,
		ReadContext:   resourceSysdigVulnerabilityRuleBundleRead,
		UpdateContext: resourceSysdigVulnerabilityRuleBundleUpdate,
		DeleteContext: resourceSysdigVulnerabilityRuleBundleDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(timeout),
			Delete: schema.DefaultTimeout(timeout),
			Update: schema.DefaultTimeout(timeout),
			Read:   schema.DefaultTimeout(timeout),
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Rule Bundle name",
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Rule Bundle description",
			},
			"identifier": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "External identifier",
			},

			"rule": {
				Type:        schema.TypeList,
				Required:    true,
				MinItems:    1,
				Description: "Rules for this bundle",
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"image_label": vulnerabilityRuleSchemaImageConfigLabel(),
						"severities_and_threats": vulnerabilityRuleSchemaSeveritiesAndThreats(),
					},
				},
			},
		},
	}
}

func vulnerabilityRuleSchemaSeveritiesAndThreats() *schema.Schema {
	return &schema.Schema{
		Type:        schema.TypeSet,
		Optional:    true,
		MaxItems:    1,
		Description: "Defines rules based on vulnerability severity and threat intelligence.",
		Elem: &schema.Resource{
			Schema: map[string]*schema.Schema{},
		},
	}
}

func getSecureVulnerabilityRuleBundleClient(c SysdigClients) (v2.VulnerabilityRuleBundleClient, error) {
	return c.sysdigSecureClientV2()
}

func resourceSysdigVulnerabilityRuleBundleCreate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityRuleBundleClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	scanningRuleBundle, err := vulnerabilityRuleBundleFromResourceData(d)
	if err != nil {
		return diag.FromErr(err)
	}

	scanningRuleBundle, err = client.CreateVulnerabilityRuleBundle(ctx, scanningRuleBundle)
	if err != nil {
		return diag.FromErr(err)
	}

	err = vulnerabilityRuleBundleToResourceData(&scanningRuleBundle, d)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceSysdigVulnerabilityRuleBundleUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityRuleBundleClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	scanningRuleBundle, err := vulnerabilityRuleBundleFromResourceData(d)
	if err != nil {
		return diag.FromErr(err)
	}

	_, err = client.UpdateVulnerabilityRuleBundle(ctx, scanningRuleBundle)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceSysdigVulnerabilityRuleBundleRead(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityRuleBundleClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	scanningRuleBundle, err := client.GetVulnerabilityRuleBundleByID(ctx, d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	err = vulnerabilityRuleBundleToResourceData(&scanningRuleBundle, d)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceSysdigVulnerabilityRuleBundleDelete(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityRuleBundleClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	err = client.DeleteVulnerabilityRuleBundleByID(ctx, d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func vulnerabilityRuleBundleToResourceData(scanningRuleBundle *v2.VulnerabilityRuleBundle, d *schema.ResourceData) error {
	if scanningRuleBundle.ID == nil {
		d.SetId("") // id is nil, let's destroy the resource
		return nil
	}

	d.SetId(strconv.Itoa(int(*scanningRuleBundle.ID)))
	_ = d.Set("name", scanningRuleBundle.Name)
	_ = d.Set("description", scanningRuleBundle.Description)

	if scanningRuleBundle.Identifier != nil {
		_ = d.Set("identifier", *scanningRuleBundle.Identifier)
	}

	ruleData, err := vulnerabilityRulesToData(scanningRuleBundle.Rules)
	if err != nil {
		return err
	}
	_ = d.Set("rule", ruleData)

	return nil
}

func vulnerabilityRulesToData(scanningRuleBundle []v2.VulnerabilityRule) ([]map[string]any, error) {
	var rules []map[string]any

	for _, ruleBundle := range scanningRuleBundle {
		data, err := vulnerabilityRuleToData(ruleBundle)
		if err != nil {
			return nil, err
		}
		rules = append(rules, data)
	}

	return rules, nil
}

func vulnerabilityRuleToData(ruleBundle v2.VulnerabilityRule) (map[string]any, error) {
	switch ruleBundle.Type {
	case v2.VulnerabilityRuleTypeImageConfigLabel:
		return vulnerabilityRuleImageConfigLabelToData(ruleBundle)
	default:
		return nil, fmt.Errorf("unsupported rule bundle type: %s", ruleBundle.Type)
	}
}

func vulnerabilityRuleImageConfigLabelToData(ruleBundle v2.VulnerabilityRule) (map[string]any, error) {
	switch ruleBundle.Predicates[0].Type {
	case "imageConfigLabelNotExists":
		return map[string]any{
			"image_label": []map[string]any{{
				"id":               ruleBundle.ID,
				"label_must_exist": ruleBundle.Predicates[0].Extra.Key,
			}},
		}, nil
	case "imageConfigLabelExists":
		return map[string]any{
			"image_label": []map[string]any{{
				"id":                   ruleBundle.ID,
				"label_must_not_exist": ruleBundle.Predicates[0].Extra.Key,
			}},
		}, nil
	case "imageConfigLabelNotContains":
		return map[string]any{
			"image_label": []map[string]any{{
				"id": ruleBundle.ID,
				"label_must_exist_and_contain_value": []map[string]any{{
					"required_label": ruleBundle.Predicates[0].Extra.Key,
					"required_value": ruleBundle.Predicates[0].Extra.Value,
				}},
			}},
		}, nil
	}

	return nil, fmt.Errorf("unsupported image config label rule for predicate: %s", ruleBundle.Predicates[0].Type)
}

func toPtr[T any](any T) *T {
	return &any
}

func vulnerabilityRuleBundleFromResourceData(d *schema.ResourceData) (v2.VulnerabilityRuleBundle, error) {
	stringPtr := func(d *schema.ResourceData, key string) *string {
		if value, ok := d.GetOk(key); ok && value.(string) != "" {
			valueAsString := value.(string)
			return &valueAsString
		}
		return nil
	}

	int32PtrFromID := func(d *schema.ResourceData) *int {
		id := d.Id()
		if id == "" {
			return nil
		}

		idAsInt, err := strconv.Atoi(id)
		if err != nil {
			return nil
		}

		return &idAsInt
	}

	rules, err := vulnerabilityRulesFromList(d.Get("rule").([]any))
	if err != nil {
		return v2.VulnerabilityRuleBundle{}, err
	}

	return v2.VulnerabilityRuleBundle{
		ID:          int32PtrFromID(d),
		Identifier:  stringPtr(d, "identifier"),
		Name:        d.Get("name").(string),
		Description: toPtr(d.Get("description").(string)),
		Rules:       rules,
	}, nil
}

func vulnerabilityRulesFromList(list []any) ([]v2.VulnerabilityRule, error) {
	var out []v2.VulnerabilityRule

	for _, ruleRaw := range list {
		if ruleRaw == nil {
			return nil, errors.New("empty rule detected, you need to specify one")
		}
		rule, err := vulnerabilityRuleFromMap(ruleRaw.(map[string]any))
		if err != nil {
			return nil, err
		}
		out = append(out, rule)
	}

	return out, nil
}

func validateRuleMap(ruleMap map[string]any) error {
	var activeRuleNames []string
	for key, val := range ruleMap {
		if val.(*schema.Set).Len() > 0 {
			activeRuleNames = append(activeRuleNames, key)
		}
	}

	if len(activeRuleNames) == 0 {
		return errors.New("you must specify one rule")
	}

	if len(activeRuleNames) > 1 {
		return fmt.Errorf("you can only specify one rule per rule block, specify more rule blocks if you need more rules, you specified: %s", activeRuleNames)
	}

	return nil
}

func vulnerabilityRuleFromMap(ruleMap map[string]any) (v2.VulnerabilityRule, error) {
	err := validateRuleMap(ruleMap)
	if err != nil {
		return v2.VulnerabilityRule{}, err
	}

	for ruleType, ruleBody := range ruleMap {
		switch v2.VulnerabilityRuleType(ruleType) {
		case "image_label":
			return vulnerabilityRuleImageConfigLabelFromMap(ruleBody.(*schema.Set).List()[0].(map[string]any))
		case "severities_and_threats":
			return vulnerabilityRuleSeveritiesAndThreatsFromMap(ruleBody.(*schema.Set).List()[0].(map[string]any))
		}

		return v2.VulnerabilityRule{}, fmt.Errorf("unsupported rule type: %s", ruleType)
	}
	panic("unreachable")
}

func vulnerabilityRuleSeveritiesAndThreatsFromMap(ruleBody map[string]any) (v2.VulnerabilityRule, error) {
	rule := v2.VulnerabilityRule{
		ID:   toPtr(ruleBody["id"].(string)),
		Type: v2.VulnerabilityRuleTypeVulnSeverityAndThreats,
	}

	// This is where the translation logic will go.
	// For now, it returns an empty rule.

	return rule, nil
}

func vulnerabilityRuleImageConfigLabelFromMap(ruleBody map[string]any) (v2.VulnerabilityRule, error) {
	rule := v2.VulnerabilityRule{
		ID:         toPtr(ruleBody["id"].(string)),
		Type:       v2.VulnerabilityRuleTypeImageConfigLabel,
		Predicates: []v2.VulnerabilityRulePredicate{},
	}

	if label, ok := ruleBody["label_must_exist"]; ok && label.(string) != "" {
		rule.Predicates = append(rule.Predicates, v2.VulnerabilityRulePredicate{
			Type: "imageConfigLabelNotExists",
			Extra: &v2.VulnerabilityRulePredicateExtra{
				Key: toPtr(label.(string)),
			},
		})
	}

	if label, ok := ruleBody["label_must_not_exist"]; ok && label.(string) != "" {
		rule.Predicates = append(rule.Predicates, v2.VulnerabilityRulePredicate{
			Type: "imageConfigLabelExists",
			Extra: &v2.VulnerabilityRulePredicateExtra{
				Key: toPtr(label.(string)),
			},
		})
	}

	if label, ok := ruleBody["label_must_exist_and_contain_value"]; ok && len(label.([]any)) > 0 {
		contents := label.([]any)[0].(map[string]any)
		rule.Predicates = append(rule.Predicates, v2.VulnerabilityRulePredicate{
			Type: "imageConfigLabelNotContains",
			Extra: &v2.VulnerabilityRulePredicateExtra{
				Key:   toPtr(contents["required_label"].(string)),
				Value: toPtr(contents["required_value"].(string)),
			},
		})
	}

	if len(rule.Predicates) == 0 {
		return v2.VulnerabilityRule{}, errors.New("no predicate has been specified for image label rule")
	}

	return rule, nil
}
