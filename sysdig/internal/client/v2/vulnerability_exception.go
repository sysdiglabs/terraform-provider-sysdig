package v2

import (
	"context"
	"fmt"
	"net/http"
)

const (
	CreateVulnerabilityExceptionListPath = "%s/api/scanning/v1/vulnexceptions"
	GetVulnerabilityExceptionListPath    = "%s/api/scanning/v1/vulnexceptions/%s"
	DeleteVulnerabilityExceptionListPath = "%s/api/scanning/v1/vulnexceptions/%s"
	UpdateVulnerabilityExceptionListPath = "%s/api/scanning/v1/vulnexceptions/%s"

	CreateVulnerabilityExceptionPath = "%s/api/scanning/v1/vulnexceptions/%s/vulnerabilities"
	GetVulnerabilityExceptionPath    = "%s/api/scanning/v1/vulnexceptions/%s/vulnerabilities/%s/"
	DeleteVulnerabilityExceptionPath = "%s/api/scanning/v1/vulnexceptions/%s/vulnerabilities/%s/"
	UpdateVulnerabilityExceptionPath = "%s/api/scanning/v1/vulnexceptions/%s/vulnerabilities/%s/"
)

type VulnerabilityExceptionListInterface interface {
	Base
	CreateVulnerabilityExceptionList(ctx context.Context, list *VulnerabilityExceptionList) (*VulnerabilityExceptionList, error)
	GetVulnerabilityExceptionListByID(ctx context.Context, id string) (*VulnerabilityExceptionList, error)
	DeleteVulnerabilityExceptionList(ctx context.Context, id string) error
	UpdateVulnerabilityExceptionList(ctx context.Context, list *VulnerabilityExceptionList) (*VulnerabilityExceptionList, error)
}

type VulnerabilityExceptionInterface interface {
	Base
	CreateVulnerabilityException(ctx context.Context, listID string, exception *VulnerabilityException) (*VulnerabilityException, error)
	GetVulnerabilityExceptionByID(ctx context.Context, listID string, exceptionID string) (*VulnerabilityException, error)
	DeleteVulnerabilityException(ctx context.Context, listID string, exceptionID string) error
	UpdateVulnerabilityException(ctx context.Context, listID string, exception *VulnerabilityException) (*VulnerabilityException, error)
}

func (client *Client) CreateVulnerabilityExceptionList(ctx context.Context, list *VulnerabilityExceptionList) (*VulnerabilityExceptionList, error) {
	payload, err := Marshal(list)
	if err != nil {
		return nil, err
	}

	response, err := client.requester.Request(ctx, http.MethodPost, client.CreateVulnerabilityExceptionListURL(), payload)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusOK && response.StatusCode != http.StatusCreated {
		return nil, client.ErrorFromResponse(response)
	}

	return Unmarshal[*VulnerabilityExceptionList](response.Body)
}

func (client *Client) GetVulnerabilityExceptionListByID(ctx context.Context, id string) (*VulnerabilityExceptionList, error) {
	response, err := client.requester.Request(ctx, http.MethodGet, client.GetVulnerabilityExceptionListURL(id), nil)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusOK && response.StatusCode != http.StatusCreated {
		return nil, client.ErrorFromResponse(response)
	}

	return Unmarshal[*VulnerabilityExceptionList](response.Body)
}

func (client *Client) DeleteVulnerabilityExceptionList(ctx context.Context, id string) error {
	response, err := client.requester.Request(ctx, http.MethodDelete, client.DeleteVulnerabilityExceptionListURL(id), nil)
	if err != nil {
		return err
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusNoContent && response.StatusCode != http.StatusOK && response.StatusCode != http.StatusNotFound {
		return client.ErrorFromResponse(response)
	}

	return nil
}

func (client *Client) UpdateVulnerabilityExceptionList(ctx context.Context, list *VulnerabilityExceptionList) (*VulnerabilityExceptionList, error) {
	payload, err := Marshal(list)
	if err != nil {
		return nil, err
	}

	response, err := client.requester.Request(ctx, http.MethodPut, client.UpdateVulnerabilityExceptionListURL(list.ID), payload)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusOK && response.StatusCode != http.StatusCreated {
		return nil, client.ErrorFromResponse(response)
	}

	return Unmarshal[*VulnerabilityExceptionList](response.Body)
}

func (client *Client) CreateVulnerabilityException(ctx context.Context, listID string, exception *VulnerabilityException) (*VulnerabilityException, error) {
	payload, err := Marshal(exception)
	if err != nil {
		return nil, err
	}

	response, err := client.requester.Request(ctx, http.MethodPost, client.CreateVulnerabilityExceptionURL(listID), payload)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusOK && response.StatusCode != http.StatusCreated {
		return nil, client.ErrorFromResponse(response)
	}

	return Unmarshal[*VulnerabilityException](response.Body)
}

func (client *Client) GetVulnerabilityExceptionByID(ctx context.Context, listID string, exceptionID string) (*VulnerabilityException, error) {
	response, err := client.requester.Request(ctx, http.MethodGet, client.GetVulnerabilityExceptionURL(listID, exceptionID), nil)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusOK && response.StatusCode != http.StatusCreated {
		return nil, client.ErrorFromResponse(response)
	}

	return Unmarshal[*VulnerabilityException](response.Body)
}

func (client *Client) DeleteVulnerabilityException(ctx context.Context, listID string, exceptionID string) error {
	response, err := client.requester.Request(ctx, http.MethodDelete, client.DeleteVulnerabilityExceptionURL(listID, exceptionID), nil)
	if err != nil {
		return err
	}
	defer response.Body.Close()

	// We will ignore the 404 error, because the exception may have been removed if the exception list has been
	// removed as well. This should not affect the user, because removing a non existing exception has no effect.
	if response.StatusCode != http.StatusNoContent && response.StatusCode != http.StatusOK && response.StatusCode != http.StatusNotFound {
		return client.ErrorFromResponse(response)
	}

	return nil
}

func (client *Client) UpdateVulnerabilityException(ctx context.Context, listID string, exception *VulnerabilityException) (*VulnerabilityException, error) {
	payload, err := Marshal(exception)
	if err != nil {
		return nil, err
	}

	response, err := client.requester.Request(ctx, http.MethodPut, client.UpdateVulnerabilityExceptionURL(listID, exception.ID), payload)
	if err != nil {
		return nil, err
	}
	defer response.Body.Close()

	if response.StatusCode != http.StatusOK && response.StatusCode != http.StatusCreated {
		return nil, client.ErrorFromResponse(response)
	}

	return Unmarshal[*VulnerabilityException](response.Body)
}

func (client *Client) CreateVulnerabilityExceptionListURL() string {
	return fmt.Sprintf(CreateVulnerabilityExceptionListPath, client.config.url)
}

func (client *Client) GetVulnerabilityExceptionListURL(id string) string {
	return fmt.Sprintf(GetVulnerabilityExceptionListPath, client.config.url, id)
}

func (client *Client) DeleteVulnerabilityExceptionListURL(id string) string {
	return fmt.Sprintf(DeleteVulnerabilityExceptionListPath, client.config.url, id)
}

func (client *Client) UpdateVulnerabilityExceptionListURL(id string) string {
	return fmt.Sprintf(UpdateVulnerabilityExceptionListPath, client.config.url, id)
}

func (client *Client) CreateVulnerabilityExceptionURL(listID string) string {
	return fmt.Sprintf(CreateVulnerabilityExceptionPath, client.config.url, listID)
}

func (client *Client) GetVulnerabilityExceptionURL(listID, ID string) string {
	return fmt.Sprintf(GetVulnerabilityExceptionPath, client.config.url, listID, ID)
}

func (client *Client) DeleteVulnerabilityExceptionURL(listID, ID string) string {
	return fmt.Sprintf(DeleteVulnerabilityExceptionPath, client.config.url, listID, ID)
}

func (client *Client) UpdateVulnerabilityExceptionURL(listID, ID string) string {
	return fmt.Sprintf(UpdateVulnerabilityExceptionPath, client.config.url, listID, ID)
}
