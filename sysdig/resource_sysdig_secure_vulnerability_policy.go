package sysdig

import (
	"context"
	"strconv"
	"time"

	v2 "github.com/draios/terraform-provider-sysdig/sysdig/internal/client/v2"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
)

func resourceSysdigSecureVulnerabilityPolicy() *schema.Resource {
	timeout := 5 * time.Minute

	return &schema.Resource{
		CreateContext: resourceSysdigVulnerabilityPolicyCreate,
		ReadContext:   resourceSysdigVulnerabilityPolicyRead,
		UpdateContext: resourceSysdigVulnerabilityPolicyUpdate,
		DeleteContext: resourceSysdigVulnerabilityPolicyDelete,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},

		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(timeout),
			Delete: schema.DefaultTimeout(timeout),
			Update: schema.DefaultTimeout(timeout),
			Read:   schema.DefaultTimeout(timeout),
		},

		Schema: map[string]*schema.Schema{
			"name": {
				Type:        schema.TypeString,
				Required:    true,
				Description: "Policy name",
			},
			"description": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Policy description",
			},
			"identifier": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "External identifier",
			},
			"bundles": {
				Type:     schema.TypeSet,
				Required: true,
				Elem:     &schema.Schema{Type: schema.TypeString},
			},

			"stages": {
				Type:     schema.TypeSet,
				Optional: true,
				Elem: &schema.Resource{
					Schema: map[string]*schema.Schema{
						"name": {
							Type:        schema.TypeString,
							Required:    true,
							Description: "Stage name: pipeline, registry, admission_control o runtime",
							ValidateDiagFunc: validation.ToDiagFunc(
								validation.StringInSlice([]string{
									"pipeline",
									"registry",
									"runtime",
								}, false)),
						},
						"configuration": {
							Type:     schema.TypeSet,
							Optional: true,
							Elem: &schema.Resource{
								Schema: map[string]*schema.Schema{
									"scope": {
										Type:        schema.TypeString,
										Required:    true,
										Description: "Scope expression for this stage",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func getSecureVulnerabilityPolicyClient(c SysdigClients) (v2.VulnerabilityPolicyClient, error) {
	return c.sysdigSecureClientV2()
}

func resourceSysdigVulnerabilityPolicyCreate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityPolicyClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	scanningPolicy, err := vulnerabilityPolicyFromResourceData(d)
	if err != nil {
		return diag.FromErr(err)
	}

	scanningPolicy, err = client.CreateVulnerabilityPolicy(ctx, scanningPolicy)
	if err != nil {
		return diag.FromErr(err)
	}

	vulnerabilityPolicyToResourceData(&scanningPolicy, d)

	return nil
}

func resourceSysdigVulnerabilityPolicyUpdate(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityPolicyClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	scanningPolicy, err := vulnerabilityPolicyFromResourceData(d)
	if err != nil {
		return diag.FromErr(err)
	}

	_, err = client.UpdateVulnerabilityPolicy(ctx, scanningPolicy)
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceSysdigVulnerabilityPolicyRead(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityPolicyClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	scanningPolicy, err := client.GetVulnerabilityPolicyByID(ctx, d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	vulnerabilityPolicyToResourceData(&scanningPolicy, d)

	return nil
}

func resourceSysdigVulnerabilityPolicyDelete(ctx context.Context, d *schema.ResourceData, meta any) diag.Diagnostics {
	client, err := getSecureVulnerabilityPolicyClient(meta.(SysdigClients))
	if err != nil {
		return diag.FromErr(err)
	}

	err = client.DeleteVulnerabilityPolicyByID(ctx, d.Id())
	if err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func vulnerabilityPolicyToResourceData(scanningPolicy *v2.VulnerabilityPolicy, d *schema.ResourceData) {
	if scanningPolicy.ID == nil {
		d.SetId("") // id is nil, let's destroy the resource
		return
	}

	d.SetId(strconv.Itoa(int(*scanningPolicy.ID)))
	_ = d.Set("name", scanningPolicy.Name)
	_ = d.Set("description", scanningPolicy.Description)

	if scanningPolicy.Identifier != nil {
		_ = d.Set("identifier", *scanningPolicy.Identifier)
	}

	_ = d.Set("bundles", vulnerabilityPolicyBundlesToData(scanningPolicy))

	stages := vulnerabilityPolicyStagesToMap(scanningPolicy.Stages)
	_ = d.Set("stages", stages)
}

func vulnerabilityPolicyStagesToMap(policyStages []v2.Stage) []map[string]any {
	var stages []map[string]any

	for _, stage := range policyStages {
		var configsMap []map[string]any

		for _, stageconfig := range stage.Configuration {
			newConfig := map[string]any{
				"scope": stageconfig.Scope,
			}
			configsMap = append(configsMap, newConfig)
		}

		stages = append(stages, map[string]any{
			"name":          stage.Name,
			"configuration": configsMap,
		})
	}

	return stages
}

func vulnerabilityPolicyBundlesToData(scanningPolicy *v2.VulnerabilityPolicy) []string {
	var bundles []string

	for _, policyBundle := range scanningPolicy.Bundles {
		bundle := strconv.Itoa(int(policyBundle.ID))

		bundles = append(bundles, bundle)
	}

	return bundles
}

func vulnerabilityPolicyFromResourceData(d *schema.ResourceData) (v2.VulnerabilityPolicy, error) {
	stringPtr := func(d *schema.ResourceData, key string) *string {
		if value, ok := d.GetOk(key); ok && value.(string) != "" {
			valueAsString := value.(string)
			return &valueAsString
		}
		return nil
	}

	int32PtrFromID := func(d *schema.ResourceData) *int32 {
		id := d.Id()
		if id == "" {
			return nil
		}

		idAsInt, err := strconv.Atoi(id)
		if err != nil {
			return nil
		}

		i32 := int32(idAsInt)
		return &i32
	}

	bundles, err := vulnerabilityPolicyBundlesFromList(d.Get("bundles").(*schema.Set))
	if err != nil {
		return v2.VulnerabilityPolicy{}, err
	}

	stages, err := vulnerabilityPolicyStagesFromSet(d.Get("stages").(*schema.Set))
	if err != nil {
		return v2.VulnerabilityPolicy{}, err
	}

	return v2.VulnerabilityPolicy{
		ID:          int32PtrFromID(d),
		Identifier:  stringPtr(d, "identifier"),
		Name:        d.Get("name").(string),
		Description: d.Get("description").(string),
		Bundles:     bundles,
		Stages:      stages,
	}, nil
}

func vulnerabilityPolicyBundlesFromList(list *schema.Set) ([]v2.Bundle, error) {
	var out []v2.Bundle

	for _, idRaw := range list.List() {
		id, err := strconv.Atoi(idRaw.(string))
		if err != nil {
			return nil, err
		}

		out = append(out, v2.Bundle{ID: int64(id)})
	}

	return out, nil
}

func vulnerabilityPolicyStagesFromSet(set *schema.Set) ([]v2.Stage, error) {
	var out []v2.Stage

	for _, raw := range set.List() {
		rawMap := raw.(map[string]any)

		out = append(out, v2.Stage{
			Name:          rawMap["name"].(string),
			Configuration: vulnerabilityPolicyConfigsFromSet(rawMap["configuration"].(*schema.Set)),
		})
	}

	return out, nil
}

func vulnerabilityPolicyConfigsFromSet(set *schema.Set) []v2.Configuration {
	var out []v2.Configuration

	for _, raw := range set.List() {
		rawMap := raw.(map[string]any)

		out = append(out, v2.Configuration{Scope: rawMap["scope"].(string)})
	}

	return out
}
